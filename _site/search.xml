<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[Flutter 插件的创建及使用]]></title>
      <url>/flutter/flutter-plugin</url>
      <content type="text"><![CDATA[在 Flutter 项目的开发中，我们需要根据自己的业务需求来创建各种各样的插件，这里记录下关于 Flutter 插件的创建及使用的过程。官方文档这里主要记录如下几点：  插件的创建  获取 Android 中的上下文 Context  Dart 调用插件方法及传参  插件调用 Dart 的方法及传参  插件中监听 Activity 的生命周期及常用的回调方法  使用 Delegate 的方式来写插件  插件的几种依赖方式（pub、本地、git）  插件的上传及注意事项插件的创建我们可以通过两种方式来创建插件，一种是使用 IDE（Android Studio 或者 Idea）来创建；另一种是通过命令来创建。使用 IDE 创建插件在菜单栏中选择 File -&gt; New -&gt; New Flutter Project 会出现如下界面选中 Flutter Plugin 然后一路 Next 就可以了。使用命令创建插件flutter create --org com.example --template=plugin plugin_name其中 com.example 是插件包名的一部分，plugin_name 是插件的名称。插件的完整包名为 com.example.plugin_name插件的目录结构使用上述两种方式中的任一种创建完成之后，插件的目录结构如下：图中包含的几个主要的目录分别为 android，example，ios，lib 这四个目录：  android 目录是一个完整的 Android 工程，用来开发 Android 端的插件功能  example 目录用来测试 Android 或者 IOS 端的插件功能  ios 目录是一个完整的 IOS 工程，用来开发 IOS 端的插件功能  lib 目录中的文件负责和 Android 或者 IOS 端的交互获取 Android 中的上下文 Context当我们创建好插件之后，Android 工程 里面会有一个生成好的文件，这里是 FlutterPluginDemoPlugin.java，如下：/** FlutterPluginDemoPlugin */public class FlutterPluginDemoPlugin implements MethodCallHandler {  /** Plugin registration.*/  public static void registerWith(Registrar registrar) {    final MethodChannel channel = new MethodChannel(registrar.messenger(), "flutter_plugin_demo");    channel.setMethodCallHandler(new FlutterPluginDemoPlugin());  }  @Override  public void onMethodCall(MethodCall call, Result result) {    // 省略部分代码  }}这个类中有一个与 Dart 层对应的 MethodChannel。这个时候，如果我们添加一个弹出 Toast 的方法。Toast 需要一个 Context 类型的参数，但是这个类中是没有提供类似 this.getContext() 的方法来提供。这个时候，需要使用Registrar 这个类来获取 Context。如下：public class FlutterPluginDemoPlugin implements MethodCallHandler {    // 上下文 Context    private final Context context;    public FlutterPluginDemoPlugin(Registrar registrar) {        this.context = registrar.context();    }    /**     * Plugin registration.     */    public static void registerWith(Registrar registrar) {        final MethodChannel channel = new MethodChannel(registrar.messenger(), "flutter_plugin_demo");        channel.setMethodCallHandler(new FlutterPluginDemoPlugin(registrar));    }    @Override    public void onMethodCall(MethodCall call, Result result) {        if (call.method.equals("getPlatformVersion")) {            result.success("Android " + android.os.Build.VERSION.RELEASE);        } else if (call.method.equals("showToast")) {            // 弹出 Toast            Toast.makeText(context, "来自 Android 端的 Toast", Toast.LENGTH_SHORT).show();        } else {            result.notImplemented();        }    }}对应的，在 flutter_plugin_demo.dart 文件中需要新增一个方法来触发弹出 Toast：class FlutterPluginDemo {  static const MethodChannel _channel =      const MethodChannel('flutter_plugin_demo');  static Future&lt;String&gt; get platformVersion async {    final String version = await _channel.invokeMethod('getPlatformVersion');    return version;  }    /// 弹出 Toast  static Future&lt;void&gt; showToast() async {    await _channel.invokeMethod("showToast");  }}然后在 example 工程中的去调用：floatingActionButton: FloatingActionButton(  onPressed: () async {    /// 调用插件的 Toast 功能    await FlutterPluginDemo.showToast();  },  child: Icon(Icons.add),),Dart 调用原生方法时传递参数将上述的 showToast 方法改成接收一个参数的方法：/// [message] Toast 的内容static Future&lt;void&gt; showToast({String message}) async {    await _channel.invokeMethod("showToast", message);}在 Java 层就需要接收这个参数：String message = String message = call.arguments();Toast.makeText(context, message, Toast.LENGTH_SHORT).show();有时候需要传递好多个参数，这个时候可以传递一个 Map，如下：/// 传递 map 类型的参数static Future&lt;void&gt; showToast() async {    Map&lt;String, String&gt; params = Map&lt;String, String&gt;();    params['name'] = 'Lili';    params['age'] = '20';    params['country'] = 'China';    await _channel.invokeMethod("showToast", params);}Java 层接收：Map&lt;String, String&gt; params = call.arguments();Toast.makeText(context, params.get("name"), Toast.LENGTH_SHORT).show();原生向 Dart 层发送通知这里我们使用 EventChannel 来让原生向 Dart 层发送通知，使用 EventChannel 的步骤如下：  Dart 层定义一个 EventChannel  Dart 层监听该 EventChannel，用来接收该 EventChannel 上的事件  原生端定义一个 EventChannel  原生端向 Dart 层发送消息Dart 层定义 EventChannelstatic const EventChannel _eventChannel = EventChannel("flutter_plugin_event");Dart 层监听该 EventChannel// 这里的 data 就是原生端发送过来的数据_eventChannel.receiveBroadcastStream().listen((data) {  //streamController.sink.add(data);});原生端定义 EventChannel原生端里面，首先需要定义一个 EventChannel ，然后需要为其设置一个 StreamHandler，在 StreamHandler 的 onListen 方法中会有一个 EventChannel.EventSink 的参数，这个参数可以用来向 Dart 层发送消息。private EventChannel.EventSink eventSink;...final EventChannel eventChannel = new EventChannel(registrar.messenger(), "flutter_plugin_event");eventChannel.setStreamHandler(new EventChannel.StreamHandler() {    @Override    public void onListen(Object o, EventChannel.EventSink eventSink) {        FlutterPluginDemoPlugin.this.eventSink = eventSink;    }    @Override    public void onCancel(Object o) {        FlutterPluginDemoPlugin.this.eventSink = null;    }});原生端向 Dart 层发送消息// 通知 Dart 层if (null != eventSink) {    eventSink.success("Dart 调用 原始方法成功");}插件中监听 Activity 常用的生命周期方法的回调生命周期方法回调有时候我们需要在 Activity 的生命周期方法中干一些事，比如友盟统计的时候，就需要在Activity 的 onResume()和 onPause() 中添加一些代码；要监听 onCreate()，onStart()，onResume() 等 方法的回调，需要借助 Application.ActivityLifecycleCallbacks 这个接口。首先写一个类 LifeCycleCallbacks 来 实现  Application.ActivityLifecycleCallbacks 这个接口，然后将其注册到 Application 的上下文中。Application.ActivityLifecycleCallbacks 接口中提供的生命周期方法如下：public interface ActivityLifecycleCallbacks {    void onActivityCreated(Activity activity, Bundle savedInstanceState);    void onActivityStarted(Activity activity);    void onActivityResumed(Activity activity);    void onActivityPaused(Activity activity);    void onActivityStopped(Activity activity);    void onActivitySaveInstanceState(Activity activity, Bundle outState);    void onActivityDestroyed(Activity activity);}所以我们只需要写一个类来实现它就可以了。然后在对应的方法里面写对应的代码。接着就是注册了：public FlutterPluginDemoPlugin(Registrar registrar) {    ...    ...    // 注册声明周期方法的监听    ((Application) registrar.context())        .registerActivityLifecycleCallbacks(new LifeCycleCallbacks());}最后在 onActivityDestroyed 生命周期方法中解注册class LifeCycleCallbacks implements Application.ActivityLifecycleCallbacks {    ...    ...    @Override    public void onActivityDestroyed(Activity activity) {        if (activity == registrar.activity()) {            ((Application) registrar.context()).unregisterActivityLifecycleCallbacks(this);        }    }  }权限监听回调public FlutterPluginDemoPlugin(Registrar registrar) {        ...        ...        // 权限监听回调        registrar.addRequestPermissionsResultListener(new PluginRegistry.RequestPermissionsResultListener() {        @Override        public boolean onRequestPermissionsResult(int i, String[] strings, int[] ints) {            return false;        }    });}startActivityForResult 的回调public FlutterPluginDemoPlugin(Registrar registrar) {    ...    ...    // startActivityForResult 回调    registrar.addActivityResultListener(new PluginRegistry.ActivityResultListener() {        @Override        public boolean onActivityResult(int requestCode, int responseCode, Intent intent) {            return false;        }    });}编写一个 Delegate 类来处理业务逻辑上一小节中，我们在 FlutterPluginDemoPlugin这一个类中处理 Activity 的声明周期的回调方法，权限申请的回调方法，Activity 跳转的回调方法。这个时候，FlutterPluginDemoPlugin 这个类的代码就会显得非常的多。我们可以写一个类来帮助插件类处理这些事情，这里写一个 PluginDelegate 类来实现这个功能：public class PluginDelegate implements        Application.ActivityLifecycleCallbacks,        PluginRegistry.RequestPermissionsResultListener,        PluginRegistry.ActivityResultListener {    private final Context context;    private final Application application;    public PluginDelegate(PluginRegistry.Registrar registrar) {        this.context = registrar.context();        this.application = (Application) context;    }    public void methodA(MethodCall call, MethodChannel.Result result){        // do something...    }    public void methodB(MethodCall call, MethodChannel.Result result){        // do something...    }    ...    ...    ...    @Override    public void onActivityDestroyed(Activity activity) {        application.unregisterActivityLifecycleCallbacks(this);    }    @Override    public boolean onRequestPermissionsResult(int i, String[] strings, int[] ints) {        return false;    }    @Override    public boolean onActivityResult(int i, int i1, Intent intent) {        return false;    }}可以看出 PluginDelegate 类实现了上一小节中需要处理的三种回调的接口，那么我们在 FlutterPluginDemoPlugin 插件类中就可以这样：public class FlutterPluginDemoPlugin implements MethodCallHandler {    ...    ...    private final PluginDelegate delegate;        // 构造方法    public FlutterPluginDemoPlugin(Registrar registrar, PluginDelegate delegate) {        ...        this.delegate = delegate;        ...        // 声明周期回调        ((Application) context).registerActivityLifecycleCallbacks(delegate);        // 权限声明回调        registrar.addRequestPermissionsResultListener(delegate);        // 页面跳转回调        registrar.addActivityResultListener(delegate);    }        /**     * Plugin registration.     */    public static void registerWith(Registrar registrar) {        final MethodChannel channel = new MethodChannel(registrar.messenger(), "flutter_plugin_demo");        // 初始化PluginDelegate        final PluginDelegate delegate = new PluginDelegate(registrar);        channel.setMethodCallHandler(new FlutterPluginDemoPlugin(registrar, delegate));    }        @Override    public void onMethodCall(MethodCall call, Result result) {        // 调用代理类方法演示        if (call.method.equals("methodA")) {            delegate.methodA(call, result);        }else if(call.method.equals("methodB")){            delegate.methodB(call, result);        }    }}插件的依赖方式官方文档这里有三种方式用来依赖插件  pub 依赖  git 依赖  本地依赖pub 依赖这种是最常见的方式，直接在 工程的 pubspec.yaml 中依赖dependencies:  flutter:    sdk: flutter  # 添加 toast 的依赖  toast: ^0.1.5git 依赖很多时候，pub 上的某个插件并不能完全满足我们实际的业务需求，如 UI 或者一些逻辑问题，这个时候我们可以将其源码下载下来，然后根据自己的业务需求对其进行修改。改完之后通常会上传到公司的私有仓库中（GitHub 或者 GitLab），然后在工程中就需要依赖私有仓库中的库dependencies: toast:    git:      url: http://xxx/toast.git还可能依赖该仓库指定分支上的代码，如依赖远程 dev 分支上的代码dependencies:  toast:     git:      ref: dev      url: http://xxx/toast.git本地依赖有时候需要在项目中测试本地的某个插件，这个时候就可以使用本地依赖的方式来依赖插件dependencies:    toast:        path: user/xxx/toast/插件的上传这里是上传到 pub.dev 上面在上传之前使用如下命令检查插件中的一些问题：flutter packages pub publish --dry-run还需要做的就是上传前的需要清理插件，避免插件过大无法上传flutter clean使用如下命令进行插件的上传flutter packages pub publish最后 github 地址]]></content>
      <categories>
        
          <category> Flutter </category>
        
      </categories>
      <tags>
        
          <tag> Flutter </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Flutter 单元测试]]></title>
      <url>/flutter/flutter-testing</url>
      <content type="text"><![CDATA[官方文档当 App 中的功能越来越多的时候，我们想要去手动测试一个功能的时候，会变的非常麻烦，这个时候就需要单元测试来帮助我们测试想要测的功能。Flutter 中提供了三种测试：  unit test ： 单元测试  widget test ： Widget 测试  integration test ： 集成测试这里记录下前两种。当创建一个新的 Flutter 工程之后，工程目录下就会有一个 test 目录，该目录用来存放测试文件：单元测试单元测试用来验证代码中的某一个方法或者某一块逻辑是否正确。写单元测试的步骤如下：  添加 test 或者 flutter_test 依赖到工程中  在 test 目录下创建一个测试文件，如： counter_test.dart  创建一个待测试的文件，如： counter.dart  在 counter_test.dart 文件中编写 test  如果有多个测试的需要在一起测试的情况下，可以使用 group  运行测试类1. 添加依赖在工程的 pubspec.yaml 中添加 flutter_test 的依赖：dev_dependencies:  flutter_test:    sdk: flutter2. 创建测试文件这里，需要创建两个文件，一个是测试类文件 counter_test.dart 还有一个是被测试文件counter.dart。当这两个文件创建完之后，目录结构如下：.├── lib│   ├── counter.dart├── test│   ├── counter_test.dart3. 编写被测试类Counter 类中的方法如下：class Counter {  int value = 0;  void increment() =&gt; value++;  void decrement() =&gt; value--;}4.编写测试类在 counter_test.dart 文件中编写单元测试，里面会使用到一些 flutter_test 包提供的顶层方法，如 test(...) 方法是用来定义一个单元测试的，还有就是 expect(...) 方法用来验证结果的。test(...) 方法里面有两个必需的参数，第一个参数表示这个单元测试的描述信息，第二个是一个 Function，用来编写测试内容的。expect(...) 方法中也有两个必需的参数，第一个是需要验证的变量，第二个是与该变量匹配的值。counter_test.dart 中的代码如下：import 'package:flutter_test/flutter_test.dart';import 'package:flutter_testing/counter.dart';/// 也可以使用命令来运行 flutter test test/counter_test.dartvoid main() {  // 单一的测试  test("测试 value 递增", () {    final counter = Counter();    counter.increment();        // 验证 counter.value 的是是否为 1    expect(counter.value, 1);  });5.使用 group 来执行多个测试import 'package:flutter_test/flutter_test.dart';import 'package:flutter_testing/counter.dart';void main() {  // 使用 group 合并多个测试。用来测试多个有关联的测试  group("Counter", () {    test("value should start at 0", () {      expect(Counter().value, 0);    });    test("value should be increment", () {      final counter = Counter();      counter.increment();      expect(counter.value, 1);    });    test("value should be decremented", () {      final counter = Counter();      counter.decrement();      expect(counter.value, -1);    });  });}6.执行单元测试如果使用的是 Android Studio 或者 Idea 开发的话，那么直接点击侧边的运行按钮来执行或者调试：如果使用的是 VSCode ，则可以使用命令来执行测试：flutter test test/counter_test.dart网络接口测试同样的，在 test 目录下新建一个文件，如：http_test.dart，在这个文件中去请求一个接口，然后验证返回的结果：import 'package:flutter_test/flutter_test.dart';import 'package:http/http.dart' as http;void main() {  test("测试网络请求", () async {    // 假如这个请求需要一个 token    final token = "54321";    final response = await http.get(      "https://api.myjson.com/bins/18mjgh",      headers: {"token": token},    );    if (response.statusCode == 200) {      // 验证请求 header 中的 token      expect(response.request.headers['token'], token);      print(response.request.headers['token']);      print(response.body);      // 解析返回的 json      Person person = parsePersonJson(response.body);      // 验证 person 对象不为空      expect(person, isNotNull);      // 检测 person 对象中的属性值是否都正确      expect(person.name, "Lili");      expect(person.age, 20);      expect(person.country, 'China');    }  });}使用 Mockito 来模拟对象依赖首先，添加 mockito 的依赖到 pubspec.yaml 中：dev_dependencies:  mockito: 4.1.1然后新建一个被测试的类：class A {  int calculate(B b) {    int randomNum = b.getRandomNum();    return randomNum * 2;  }}class B {  int getRandomNum() {    return Random().nextInt(100);  }}  上述代码中，类 A 的 calculate 方法是依赖类 B 的。这时测试 calculate 方法的时候可以使用 mockito 来模拟一个类 B接着新建一个测试类：import 'package:flutter_test/flutter_test.dart';import 'package:flutter_testing/mock_d.dart';import 'package:mockito/mockito.dart';/// 使用 mockito 模拟一个类 Bclass MockB extends Mock implements B {}void main() {  test("测试使用 mockito 来 mock 依赖", () {    var b = MockB();    var a = A();    // 当调用 b.getRandomNum() 方法的时候返回 10    when(b.getRandomNum()).thenReturn(10);    expect(a.calculate(b), 20);    // 检查 b.getRandomNum(); 是否调用过    verify(b.getRandomNum());  });}官方文档上还有一个这样的例子，是使用 mockito 来模拟接口返回的数据，要测试的方法如下：Future&lt;Post&gt; fetchPost(http.Client client) async {  final response =      await client.get("https://jsonplaceholder.typicode.com/posts/1");  if (response.statusCode == 200) {    return Post.fromJson(json.decode(response.body));  } else {    throw Exception('Failed to load post');  }}上述方法中就是请求一个接口，请求成功则解析返回，否则抛出异常。测试该方法的代码如下：import 'package:flutter_test/flutter_test.dart';import 'package:flutter_testing/post_service.dart';import 'package:http/http.dart' as http;import 'package:mockito/mockito.dart';/// 使用 mock 模拟一个 http.Client 对象class MockClient extends Mock implements http.Client {}void main() {  group("fetchPost", () {    test("接口返回数据正确", () async {      final client = MockClient();      // 当调用指定的接口的时候返回指定的数据      when(client.get("https://jsonplaceholder.typicode.com/posts/1"))          .thenAnswer((_) async {        return http.Response(            '{"title": "test title", "body": "test body"}', 200);      });      var post = await fetchPost(client);      expect(post.title, "test title");    });    test("接口返回数据错误，抛出异常", () {      final client = MockClient();      // 当调用这个接口的时候返回 Not Found      when(client.get("https://jsonplaceholder.typicode.com/posts/1"))          .thenAnswer((_) async {        return http.Response('Not Found', 404);      });      expect(fetchPost(client), throwsException);    });  });}Widget 测试Widget 测试和单元测试一个很明显的区别就是 Widget 测试使用的顶层函数是 testWidgets，该函数的写法如下：testWidgets('这是一个 Widget 测试', (WidgetTester tester){});我们可以使用 WidgetTester 来 build 需要测试的 widget，或者执行重绘(相当于调用了 setState(...) 方法。还有就是可以使用另外一个顶层函数 find 来定位到需要操作的 widget，如：find.text('title'); // 通过 text 来定位 widgetfind.byIcon(Icons.add); // 通过 Icon 来定位 widgetfind.byWidget(myWidget); // 通过 widget 的引用来定位 widgetfind.byKey(Key('value')); // 通过 key 来定位 widget测试页面中是否包含某一个 widget待测试的页面 MyWidgetclass MyWidget extends StatelessWidget {  final String title;  final String message;  const MyWidget({Key key, @required this.title, @required this.message})      : super(key: key);  @override  Widget build(BuildContext context) {    return MaterialApp(      title: 'Flutter Demo',      home: Scaffold(        appBar: AppBar(          title: Text(title),        ),        body: Center(          child: Text(message),        ),      ),    );  }}上述页面中，有两个 Text 分别为 text(title) 和 text(message)，下面编写测试类来验证页面中是否包含着两个 Text：  testWidgets("MyWidget has a title and message", (WidgetTester tester) async {    // 加载 MyWidget    await tester.pumpWidget(MyWidget(      title: "T",      message: "M",    ));    final titleFinder = find.text('T');    final messageFinder = find.text('M');        // 验证页面中是否含有上述的两个 Text    expect(titleFinder, findsOneWidget);    expect(messageFinder, findsOneWidget);  });  注意：待测试的 widget 需要用 MaterialApp() 包裹；上述代码中的 findsOneWidget 表示在页面中发现了一个与 titleFinder 对应的 Widget，与之对应的还有 findsNothing 表示页面中没有要寻找的 Widget测试页面中和用户交互的部分上一个实例中，我们使用 WidgetTester 来找页面中的 widget，WidgetTester 还能帮助我们模拟输入，点击，滑动操作，下面，还是官方的例子：待测试的页面如下：import 'package:flutter/material.dart';/// Date: 2019-09-29 14:44/// Author: Liusilong/// Description://class TodoList extends StatefulWidget {  @override  _TodoListState createState() =&gt; _TodoListState();}class _TodoListState extends State&lt;TodoList&gt; {  static const _appTitle = 'Todo List';  final todos = &lt;String&gt;[];  final controller = TextEditingController();  @override  Widget build(BuildContext context) {    return MaterialApp(      title: _appTitle,      home: Scaffold(        appBar: AppBar(          title: Text(_appTitle),        ),        body: Column(          children: &lt;Widget&gt;[            TextField(              controller: controller,            ),            Expanded(              child: ListView.builder(                  itemCount: todos.length,                  itemBuilder: (BuildContext context, int index) {                    final todo = todos[index];                    return Dismissible(                      key: Key('$todo$index'),                      onDismissed: (direction) =&gt; todos.removeAt(index),                      child: ListTile(title: Text(todo)),                      background: Container(color: Colors.red),                    );                  }),            ),          ],        ),        floatingActionButton: FloatingActionButton(          onPressed: () {            setState(() {              if (controller.text.isNotEmpty) {                todos.add(controller.text);                controller.clear();              }            });          },          child: Icon(Icons.add),        ),      ),    );  }}该页面的运行效果如下：测试类如下：  testWidgets('Add and remove a todo', (WidgetTester tester) async {    // Build the widget    await tester.pumpWidget(TodoList());    // 往输入框中输入 hi    await tester.enterText(find.byType(TextField), 'hi');    // 点击 button 来触发事件    await tester.tap(find.byType(FloatingActionButton));    // 让 widget 重绘    await tester.pump();    // 检测 text 是否添加到 List 中    expect(find.text('hi'), findsOneWidget);    // 测试滑动    await tester.drag(find.byType(Dismissible), Offset(500.0, 0.0));    // 页面会一直刷新，直到最后一帧绘制完成    await tester.pumpAndSettle();    // 验证页面中是否还有 hi 这个 item    expect(find.text('hi'), findsNothing);  });其实我感觉只要业务逻辑和 UI 分离开来，单元测试写起来还是比较方便的。最近项目开始逐步转向使用 Provider 来进行状态的管理。建议看看 Flutter Architecture - My Provider Implementation Guide 这个系列的文章，讲的很好。大致结构如下：最后，看了 My Provider Implementation Guide 系列的文章之后，写了一个 APP，有兴趣的可以下载体验下。]]></content>
      <categories>
        
          <category> Flutter </category>
        
      </categories>
      <tags>
        
          <tag> Flutter </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Flutter 双击返回键退出 APP]]></title>
      <url>/flutter/flutter-double-back-exit-app</url>
      <content type="text"><![CDATA[参考链接我们可以使用 WillPopScope 这个 widget 来帮助我们相应 Android 上的返回键，下面是双击返回键退出 APPDateTime currentBackPressTime;@overrideWidget build(BuildContext context) {  return Scaffold(    ...    body: WillPopScope(child: getBody(), onWillPop: onWillPop),  );}Future&lt;bool&gt; onWillPop() {    DateTime now = DateTime.now();    if (currentBackPressTime == null ||         now.difference(currentBackPressTime) &gt; Duration(seconds: 2)) {      currentBackPressTime = now;      Fluttertoast.showToast(msg: exit_warning);      return Future.value(false);    }    return Future.value(true);  }退出 APP 可以使用 exit(0)，如：RaisedButton(    child: Text("exit"),    onPressed: () {    exit(0);    },)]]></content>
      <categories>
        
          <category> Flutter </category>
        
      </categories>
      <tags>
        
          <tag> Flutter </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Next Theme Tutorial]]></title>
      <url>/tutorial/2017/07/20/next-tutorial/</url>
      <content type="text"><![CDATA[  NexT is a high quality elegant Jekyll theme ported from Hexo Next. It is crafted from scratch, with love.Live PreviewScreenshots      Desktop        Sidebar    Sidebar (Post details page)  MobileInstallationCheck whether you have Ruby 2.1.0 or higher installed:ruby --versionInstall Bundler:gem install bundlerClone Jacman theme:git clone https://github.com/Simpleyyt/jekyll-theme-next.gitcd jekyll-theme-nextInstall Jekyll and other dependencies from the GitHub Pages gem:bundle installRun your Jekyll site locally:bundle exec jekyll serverMore Details：Setting up your GitHub Pages site locally with JekyllFeaturesMultiple languages support, including: English / Russian / French / German / Simplified Chinese / Traditional Chinese.Default language is English.language: en# language: zh-Hans# language: fr-FR# language: zh-hk# language: zh-tw# language: ru# language: deSet language field as following in site _config.yml to change to Chinese.language: zh-HansComment support.NexT has native support for DuoShuo and Disqus comment systems.Add the following snippets to your _config.yml:duoshuo:  enable: true  shortname: your-duoshuo-shortnameORdisqus_shortname: your-disqus-shortnameSocial MediaNexT can automatically add links to your Social Media accounts:social:  GitHub: your-github-url  Twitter: your-twitter-url  Weibo: your-weibo-url  DouBan: your-douban-url  ZhiHu: your-zhihu-urlFeed link.  Show a feed link.Set rss field in theme’s _config.yml, as the following value:  rss: false will totally disable feed link.      rss:   use sites’ feed link. This is the default option.    Follow the installation instruction in the plugin’s README. After the configuration is done for this plugin, the feed link is ready too.    rss: http://your-feed-url set specific feed link.Up to 5 code highlight themes built-in.NexT uses Tomorrow Theme with 5 themes for you to choose from.Next use normal by default. Have a preview about normal and night:Head over to Tomorrow Theme for more details.ConfigurationNexT comes with few configurations.# Menu configuration.menu:  home: /  archives: /archives# Faviconfavicon: /favicon.ico# Avatar (put the image into next/source/images/)# can be any image format supported by web browsers (JPEG,PNG,GIF,SVG,..)avatar: /default_avatar.png# Code highlight theme# available: normal | night | night eighties | night blue | night brighthighlight_theme: normal# Fancybox for image galleryfancybox: true# Specify the date when the site was setupsince: 2013Browser supportDart/// 这里是注释void toHomePage(BuildContext context) {  Navigator.of(context).pushAndRemoveUntil(      MaterialPageRoute(        builder: (context) =&gt; HomePage(          isGrayVersion: UpgradeAppBloc.isGrayVersion,        ),      ), (r) {    return false;  });}]]></content>
      <categories>
        
          <category> tutorial </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
