---
title:  "Flutter 插件的创建及使用"
date:   2019-10-08 17:35:36
author: 刘斯龙
categories: Flutter
tags: Flutter
permalink: /:categories/flutter-plugin
---

在 Flutter 项目的开发中，我们需要根据自己的业务需求来创建各种各样的插件，这里记录下关于 Flutter 插件的创建及使用的过程。

[官方文档](https://flutter.dev/docs/development/packages-and-plugins/developing-packages#developing-plugin-packages)

这里记录如下几点：
- **插件的创建**
- **获取 Android 中的上下文 Context**
- **Dart 调用插件方法及传参**
- **插件调用 Dart 的方法及传参**
- **插件中监听 Activity 的生命周期及权限的回调以及 onActivityForResult**
- **使用 Delegate 的方式来写插件**
- **插件的几种依赖方式（本地、git、pub）**
- **插件的上传及注意事项**

## 插件的创建
我们可以通过两种方式来创建插件，一种是使用 IDE（Android Studio 或者 Idea）来创建；另一种是通过命令来创建。

### 使用 IDE 创建插件

在菜单栏中选择 `File -> New -> New Flutter Project` 会出现如下界面

![](https://user-gold-cdn.xitu.io/2019/10/8/16daad87cb206f19?w=1812&h=1088&f=png&s=120909)

选中 `Flutter Plugin` 然后一路 `Next` 就可以了。

### 使用命令创建插件

```shell
flutter create --org com.example --template=plugin plugin_name
```

其中 `com.example` 是插件包名的一部分，`plugin_name` 是插件的名称。插件的完整包名为 `com.example.plugin_name`

### 插件的目录结构
使用上述两种方式中的任一种创建完成之后，插件的目录结构如下：

![](https://user-gold-cdn.xitu.io/2019/10/8/16daae74c2a750bc?w=608&h=888&f=png&s=105241)

图中包含的几个主要的目录分别为 **android**，**example**，**ios**，**lib** 这四个目录：
- android 目录是一个完整的 Android 工程，用来开发 Android 端的插件功能
- example 目录用来测试 Android 或者 IOS 端的插件功能
- ios 目录是一个完整的 IOS 工程，用来开发 IOS 端的插件功能
- lib 目录中的文件负责和 Android 或者 IOS 端的交互

## 获取 Android 中的上下文 Context

当我们创建好插件之后，Android工程 里面会有一个生成好的文件，这里是 `FlutterPluginDemoPlugin.java`，如下：
```java
/** FlutterPluginDemoPlugin */
public class FlutterPluginDemoPlugin implements MethodCallHandler {
  /** Plugin registration.*/
  public static void registerWith(Registrar registrar) {
    final MethodChannel channel = new MethodChannel(registrar.messenger(), "flutter_plugin_demo");
    channel.setMethodCallHandler(new FlutterPluginDemoPlugin());
  }

  @Override
  public void onMethodCall(MethodCall call, Result result) {
    // 省略部分代码
  }
}
```

这个类中有一个与 Dart 层对应的 MethodChannel。

这个时候，如果我们添加一个弹出 Toast 的方法。Toast 需要一个 Context 类型的参数，但是这个类中是没有提供类似 `this.getContext()` 的方法来提供。这个时候，需要使用`Registrar` 这个类来获取 `Context`。如下：

```java
public class FlutterPluginDemoPlugin implements MethodCallHandler {
    private final Registrar registrar;
    // 上下文 Context
    private final Context context;

    public FlutterPluginDemoPlugin(Registrar registrar) {
        this.registrar = registrar;
        this.context = registrar.context();
    }

    /**
     * Plugin registration.
     */
    public static void registerWith(Registrar registrar) {
        final MethodChannel channel = new MethodChannel(registrar.messenger(), "flutter_plugin_demo");
        channel.setMethodCallHandler(new FlutterPluginDemoPlugin(registrar));
    }

    @Override
    public void onMethodCall(MethodCall call, Result result) {
        if (call.method.equals("getPlatformVersion")) {
            result.success("Android " + android.os.Build.VERSION.RELEASE);
        } else if (call.method.equals("showToast")) {
            // 弹出 Toast
            Toast.makeText(context, "来自 Android 端的 Toast", Toast.LENGTH_SHORT).show();
        } else {
            result.notImplemented();
        }
    }
}
```

对应的，在 flutter_plugin_demo.dart 文件中需要新增一个方法来触发弹出 Toast：

```dart
class FlutterPluginDemo {
  static const MethodChannel _channel =
      const MethodChannel('flutter_plugin_demo');

  static Future<String> get platformVersion async {
    final String version = await _channel.invokeMethod('getPlatformVersion');
    return version;
  }
  
  /// 弹出 Toast
  static Future<void> showToast() async {
    await _channel.invokeMethod("showToast");
  }

}
```

然后在 example 工程中的去调用：

```dart
floatingActionButton: FloatingActionButton(
  onPressed: () async {
    /// 调用插件的 Toast 功能
    await FlutterPluginDemo.showToast();
  },
  child: Icon(Icons.add),
),
```


